#!/usr/bin/env python3
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#

import os
import sys
import shutil
import signal
import time

from xml.sax import make_parser
from xml.sax.handler import feature_namespaces
from xml.sax.handler import ContentHandler

from xml.dom.minidom import parse

progname = os.path.basename(sys.argv[0])
contentHandler = None
propertyClasses = {}

commonPreamble = f"""\
// Copyright (c) ZeroC, Inc. All rights reserved.

// Generated by makeprops.py from PropertyNames.xml, {time.ctime()}

// IMPORTANT: Do not edit this file -- any edits made here will be lost!
"""

cppHeaderPreamble = (
    commonPreamble
    + """
#ifndef ICE_INTERNAL_PROPERTY_NAMES_H
#define ICE_INTERNAL_PROPERTY_NAMES_H

#include <string>

namespace IceInternal
{

struct Property
{
    const char* pattern;
    bool usesRegex;
    const char* defaultValue;
    bool deprecated;

    Property(const char* n, bool r, const char* dv, bool d) :
        pattern(n),
        usesRegex(r),
        defaultValue(dv),
        deprecated(d)
    {
    }

    Property() = delete;
};

struct PropertyArray
{
    const Property* properties;
    const int length;

    PropertyArray(const Property* p, size_t len) :
        properties(p),
        length(static_cast<int>(len))
    {
    }
};

class PropertyNames
{
public:

"""
)

cppHeaderPostamble = """
    static const PropertyArray validProps[];
    static const char* clPropNames[];
};

}

#endif
"""

cppSrcPreamble = (
    commonPreamble
    + """
#include "PropertyNames.h"

"""
)

javaPreamble = (
    commonPreamble
    + """
package com.zeroc.IceInternal;

public final class PropertyNames
{
"""
)

csPreamble = (
    commonPreamble
    + """
namespace Ice.Internal;

public sealed class PropertyNames
{
"""
)

jsPreamble = (
    commonPreamble
    + """
/* eslint comma-dangle: "off" */
/* eslint array-bracket-newline: "off" */
/* eslint no-useless-escape: "off" */

import { Property } from "./Property";
export const PropertyNames = {};
"""
)

jsEpilogue = ""


#
# Currently the processing of PropertyNames.xml is going to take place
# in two parts. One is using DOM to extract the property 'classes' such
# as 'proxy', 'objectadapter', etc. The other part uses SAX to create
# the language mapping source code.
#


class PropertyClass:
    def __init__(self, prefixOnly, childProperties):
        self.prefixOnly = prefixOnly
        self.childProperties = childProperties

    def getChildren(self):
        return self.childProperties

    def isPrefixOnly(self):
        return self.prefixOnly

    def __repr__(self):
        return repr((repr(self.prefixOnly), repr(self.childProperties)))


def initPropertyClasses(filename):
    doc = parse(filename)
    propertyClassNodes = doc.getElementsByTagName("class")
    global propertyClasses
    propertyClasses = {}
    for n in propertyClassNodes:
        className = n.attributes["name"].nodeValue
        classType = n.attributes["prefix-only"].nodeValue
        properties = []
        for a in n.childNodes:
            if a.localName == "suffix" and a.hasAttributes():
                """Convert minidom maps to hash tables """
                attributeMap = {}
                for i in range(0, a.attributes.length):
                    attributeMap[a.attributes.item(i).name] = a.attributes.item(i).value
                properties.append(attributeMap)

        propertyClasses[className] = PropertyClass(
            classType.lower() == "true", properties
        )


#
# SAX part.
#


def handler(sigNum, frame):
    """Installed as signal handler. Should cause an files that are in
    use to be closed and removed"""
    global contentHandler
    contentHandler.cleanup()
    sys.exit(128 + sigNum)


class UnknownElementException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class PropertyHandler(ContentHandler):
    def __init__(self):
        self.start = False
        self.currentSection = None
        self.sectionPropertyCount = 0
        self.sections = []
        self.cmdLineOptions = []

    def cleanup(self):
        # Needs to be overridden in derived class
        pass

    def startFiles(self):
        # Needs to be overridden in derived class
        pass

    def closeFiles(self):
        # Needs to be overridden in derived class
        pass

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        # Needs to be overridden in derived class
        pass

    def newSection(self, sectionName):
        # Needs to be overridden in derived class
        pass

    def moveFiles(self, location):
        # Needs to be overridden in derived class
        pass

    def handleNewSection(self, sectionName, noCmdLine):
        self.currentSection = sectionName
        self.sectionPropertyCount = 0
        if noCmdLine == "false":
            self.cmdLineOptions.append(sectionName)
        self.sections.append(sectionName)
        self.newSection()

    def handleProperty(self, propertyName, usesRegex, defaultValue, deprecated):
        self.propertyImpl(propertyName, usesRegex, defaultValue, deprecated)

    def startElement(self, name, attrs):
        if name == "properties":
            self.start = True
            self.startFiles()
            return

        if not self.start:
            return

        if name == "section":
            noCmdLine = attrs.get("noCmdLine", "false")
            self.handleNewSection(attrs.get("name"), noCmdLine)

        elif name == "property":
            propertyName = attrs.get("name", None)
            if "class" in attrs:
                c = propertyClasses[attrs["class"]]
                for p in c.getChildren():
                    assert propertyName is not None
                    assert propertyName != ""
                    t = dict(p)
                    t["name"] = "%s.%s" % (propertyName, p["name"])
                    self.startElement(name, t)
                if c.isPrefixOnly():
                    return

            usesRegex = "[any]" in propertyName
            deprecated = attrs.get("deprecated", "false").lower() == "true"
            defaultValue = attrs.get("default", None) or ""
            self.handleProperty(propertyName, usesRegex, defaultValue, deprecated)

    def endElement(self, name):
        if name == "properties":
            self.closeFiles()
        elif name == "section":
            self.closeSection()


class CppPropertyHandler(PropertyHandler):
    def __init__(self):
        PropertyHandler.__init__(self)
        self.hFile = None
        self.cppFile = None

    def cleanup(self):
        if self.hFile is not None:
            self.hFile.close()
            if os.path.exists("PropertyNames.h"):
                os.remove("PropertyNames.h")
        if self.cppFile is not None:
            self.cppFile.close()
            if os.path.exists("PropertyNames.cpp"):
                os.remove("PropertyNames.cpp")

    def startFiles(self):
        self.hFile = open("PropertyNames.h", "w")
        self.cppFile = open("PropertyNames.cpp", "w")
        self.hFile.write(cppHeaderPreamble)
        self.cppFile.write(cppSrcPreamble)

    def closeFiles(self):
        self.hFile.write(cppHeaderPostamble)
        self.cppFile.write(
            "const IceInternal::PropertyArray "
            "IceInternal::PropertyNames::validProps[] =\n"
        )

        self.cppFile.write("{\n")
        for s in self.sections:
            self.cppFile.write("    %sProps,\n" % s)
        self.cppFile.write("    IceInternal::PropertyArray(0,0)\n")
        self.cppFile.write("};\n\n")

        self.cppFile.write("const char* IceInternal::PropertyNames::clPropNames[] =\n")
        self.cppFile.write("{\n")
        for s in self.cmdLineOptions:
            self.cppFile.write('    "%s",\n' % s)
        self.cppFile.write("    0\n")
        self.cppFile.write("};\n")
        self.hFile.close()
        self.cppFile.close()

    def fix(self, propertyName):
        return propertyName.replace("[any]", "*")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"

        propertyLine = 'IceInternal::Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=self.fix(name) if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )

        self.cppFile.write(f"    {propertyLine},\n")

    def newSection(self):
        self.hFile.write(
            "    static const PropertyArray %sProps;\n" % self.currentSection
        )
        self.cppFile.write(
            "const IceInternal::Property %sPropsData[] =\n" % self.currentSection
        )
        self.cppFile.write("{\n")

    def closeSection(self):
        self.cppFile.write("};\n")
        self.cppFile.write(
            f"""
const IceInternal::PropertyArray
    IceInternal::PropertyNames::{self.currentSection}Props({self.currentSection}PropsData,
        sizeof({self.currentSection}PropsData)/sizeof({self.currentSection}PropsData[0]));

"""
        )

    def moveFiles(self, location):
        dest = os.path.join(location, "cpp", "src", "Ice")
        if os.path.exists(os.path.join(dest, "PropertyNames.h")):
            os.remove(os.path.join(dest, "PropertyNames.h"))
        if os.path.exists(os.path.join(dest, "PropertyNames.cpp")):
            os.remove(os.path.join(dest, "PropertyNames.cpp"))
        shutil.move("PropertyNames.h", dest)
        shutil.move("PropertyNames.cpp", dest)


class JavaPropertyHandler(PropertyHandler):
    def __init__(self):
        PropertyHandler.__init__(self)
        self.srcFile = None

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists("PropertyNames.java"):
                os.remove("PropertyNames.java")

    def startFiles(self):
        self.srcFile = open("PropertyNames.java", "w")
        self.srcFile.write(javaPreamble)

    def closeFiles(self):
        self.srcFile.write("    public static final Property[] validProps[] =\n")

        self.srcFile.write("    {\n")
        for s in self.sections:
            self.srcFile.write("        %sProps,\n" % s)
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n")

        self.srcFile.write("\n    public static final String clPropNames[] =\n")
        self.srcFile.write("    {\n")
        for s in self.cmdLineOptions:
            self.srcFile.write('        "%s",\n' % s)
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n")
        self.srcFile.write("}\n")
        self.srcFile.close()

    def fix(self, propertyName):
        #
        # The Java property strings are actually regexp's that will be passed to Java's regexp facility.
        #
        return propertyName.replace(".", r"\\.").replace("[any]", r"[^\\s]+")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"
        line = 'new Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=self.fix(name) if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )
        self.srcFile.write(f"        {line},\n")

    def newSection(self):
        self.srcFile.write(
            "    public static final Property %sProps[] =\n" % self.currentSection
        )
        self.srcFile.write("    {\n")

    def closeSection(self):
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n\n")

    def moveFiles(self, location):
        dest = os.path.join(
            location,
            "java",
            "src",
            "Ice",
            "src",
            "main",
            "java",
            "com",
            "zeroc",
            "IceInternal",
        )
        if os.path.exists(os.path.join(dest, "PropertyNames.java")):
            os.remove(os.path.join(dest, "PropertyNames.java"))
        shutil.move("PropertyNames.java", dest)


class CSPropertyHandler(PropertyHandler):
    def __init__(self):
        PropertyHandler.__init__(self)
        self.srcFile = None

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists("PropertyNames.cs"):
                os.remove("PropertyNames.cs")

    def startFiles(self):
        self.srcFile = open("PropertyNames.cs", "w")
        self.srcFile.write(csPreamble)

    def closeFiles(self):
        self.srcFile.write("    public static Property[][] validProps =\n")

        self.srcFile.write("    {\n")
        for s in self.sections:
            self.srcFile.write("        %sProps,\n" % s)
        self.srcFile.write("    };\n\n")

        self.srcFile.write("    public static string[] clPropNames =\n")
        self.srcFile.write("    {\n")
        for s in self.cmdLineOptions:
            self.srcFile.write('        "%s",\n' % s)
        self.srcFile.write("    };\n")
        self.srcFile.write("}\n")
        self.srcFile.close()

    def fix(self, propertyName):
        return propertyName.replace(".", r"\.").replace("[any]", r"[^\s]+")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"
        line = 'new(@"{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=f"^{self.fix(name)}$" if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )
        self.srcFile.write(f"         {line},\n")

    def newSection(self):
        self.srcFile.write(
            "    public static Property[] %sProps =\n" % self.currentSection
        )
        self.srcFile.write("    {\n")

    def closeSection(self):
        self.srcFile.write("    };\n")
        self.srcFile.write("\n")

    def moveFiles(self, location):
        dest = os.path.join(location, "csharp", "src", "Ice", "Internal")
        if os.path.exists(os.path.join(dest, "PropertyNames.cs")):
            os.remove(os.path.join(dest, "PropertyNames.cs"))
        shutil.move("PropertyNames.cs", dest)


class JSPropertyHandler(PropertyHandler):
    def __init__(self):
        PropertyHandler.__init__(self)
        self.srcFile = None
        self.validSections = ["Ice"]

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists("PropertyNames.js"):
                os.remove("PropertyNames.js")

    def startFiles(self):
        self.srcFile = open("PropertyNames.js", "w")
        self.srcFile.write(jsPreamble)

    def closeFiles(self):
        self.srcFile.write("PropertyNames.validProps =\n")
        self.srcFile.write("[\n")
        for s in self.sections:
            if s in self.validSections:
                self.srcFile.write(f"    PropertyNames.{s}Props,\n")
        self.srcFile.write("];\n\n")

        self.srcFile.write("PropertyNames.clPropNames =\n")
        self.srcFile.write("[\n")
        for s in self.cmdLineOptions:
            if s in self.validSections:
                self.srcFile.write(f'    "{s}",\n')
        self.srcFile.write("];\n")

        self.srcFile.write(jsEpilogue)
        self.srcFile.close()

    def fix(self, propertyName):
        return propertyName.replace(".", "\\.").replace("[any]", ".")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        if self.currentSection in self.validSections:
            name = f"{self.currentSection}.{propertyName}"
            line = 'new Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
                pattern=f"^{self.fix(name)}" if usesRegex else name,
                usesRegex="true" if usesRegex else "false",
                defaultValue=f'"{defaultValue}"',
                deprecated="true" if deprecated else "false",
            )
            self.srcFile.write(f"    {line},\n")

    def newSection(self):
        if self.currentSection in self.validSections:
            self.skipSection = False
            self.srcFile.write(f"PropertyNames.{self.currentSection}Props =\n")
            self.srcFile.write("[\n")

    def closeSection(self):
        if self.currentSection in self.validSections:
            self.srcFile.write("];\n")
            self.srcFile.write("\n")

    def moveFiles(self, location):
        dest = os.path.join(location, "js", "src", "Ice")
        if os.path.exists(os.path.join(dest, "PropertyNames.js")):
            os.remove(os.path.join(dest, "PropertyNames.js"))
        shutil.move("PropertyNames.js", dest)


class MultiHandler(PropertyHandler):
    def __init__(self, handlers):
        self.handlers = handlers
        PropertyHandler.__init__(self)

    def cleanup(self):
        for f in self.handlers:
            f.cleanup()

    def startFiles(self):
        for f in self.handlers:
            f.startFiles()

    def closeFiles(self):
        for f in self.handlers:
            f.closeFiles()

    def newSection(self):
        for f in self.handlers:
            f.newSection()

    def closeSection(self):
        for f in self.handlers:
            f.closeSection()

    def handleNewSection(self, sectionName, cmdLine):
        for f in self.handlers:
            f.handleNewSection(sectionName, cmdLine)

    def handleProperty(self, propertyName, usesRegex, default, deprecated):
        for f in self.handlers:
            f.handleProperty(propertyName, usesRegex, default, deprecated)

    def startElement(self, name, attrs):
        for f in self.handlers:
            f.startElement(name, attrs)

    def moveFiles(self, location):
        for f in self.handlers:
            f.moveFiles(location)


def main():
    if len(sys.argv) != 1 and len(sys.argv) != 3:
        print(sys.stderr, "makeprops.py does not take any arguments")
        sys.exit(1)

    # Find the top-level directory of the Ice repository
    topLevel = os.popen("git rev-parse --show-toplevel").read().strip()
    propsFile = os.path.join(topLevel, "config", "PropertyNames.xml")

    if not os.path.exists(propsFile):
        print(
            sys.stderr,
            "Cannot find top-level directory. Please run this script from the Ice repository.",
        )
        sys.exit(1)

    global contentHandler

    contentHandler = MultiHandler(
        [
            CppPropertyHandler(),
            JavaPropertyHandler(),
            CSPropertyHandler(),
            JSPropertyHandler(),
        ]
    )

    #
    # Install signal handler so we can remove the output files if we are interrupted.
    #
    signal.signal(signal.SIGINT, handler)
    # signal.signal(signal.SIGHUP, handler)
    signal.signal(signal.SIGTERM, handler)
    initPropertyClasses(propsFile)

    parser = make_parser()
    parser.setFeature(feature_namespaces, 0)
    parser.setContentHandler(contentHandler)
    pf = open(propsFile)
    try:
        parser.parse(pf)
        contentHandler.moveFiles(topLevel)
    except Exception as ex:
        print(sys.stderr, str(ex))
        contentHandler.cleanup()
        sys.exit(1)


if __name__ == "__main__":
    main()
